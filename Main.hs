{-# LANGUAGE RecursiveDo #-}
import Data.Map (Map, fromSet, elems)
import Data.Set (fromList)
import Data.List (minimumBy)
import Data.Time.Clock (getCurrentTime)
import Data.Monoid ((<>))
import Data.Function (on)
import Control.Monad.Trans (liftIO)

import Reflex.Dom 
import Reflex.Dom.Time 

type Cell = (Int, Int)
type Board = [Cell]
type Tour = [Cell]


--------------------------------------------------------------------------------
-- Knight's Tour generation functionality follows...
--------------------------------------------------------------------------------
-- | Return a list of locations that can be reached in one move.
nextMoves :: Board -> Tour -> Cell -> [Cell]
nextMoves board tour (x,y) = 
    [pos | let c = [ 1,  2, -1, -2]
         , cx <- c 
         , cy <- c 
         , abs cx /= abs cy        
         , let pos = (x+cx, y+cy)  -- in "board coordinates"
         , pos `elem` board        -- position is on the board...
         , not (pos `elem` tour) ] -- but not already on the tour


--- | Return the preferred location reachable in one move.
bestMove :: Board -> Tour -> Maybe Cell

bestMove _ [] = Nothing -- no best move if no tour is in progress

bestMove board tour@(x:_) = 
    let options = nextMoves board tour x
    in case options of
       [] -> Nothing -- if no next move then no best move.
       _ -> Just $ minimumBy (compare `on` (length . nextMoves board tour)) options


data Msg = Advance | SetStart Cell

-- | FRP style update function.
-- | Given a board, a message, and an existing tour, return an updated tour.
update :: Board -> Msg -> Tour -> Tour

update _ (SetStart start) _ = [start] -- a new tour with designated start point.

update board Advance tour = -- A
    case bestMove board tour of  -- get best move for board/tour.
        Just best -> best:tour  -- prepend best to current tour.
        Nothing -> tour  -- if no best move then nothing changes.


--------------------------------------------------------------------------------
-- SVG display functionality follows...
--------------------------------------------------------------------------------

-- | Namespace needed for svg elements.
svgNamespace = Just "http://www.w3.org/2000/svg"

-- | Display a single checker.
-- | Return click event with checker's location.
showChecker :: MonadWidget t m => Cell -> m (Event t Msg)
showChecker cell@(r, c) = do
    (el, _) <- elDynAttrNS' svgNamespace "rect" 
                   (constDyn $  "x" =: show c 
                             <> "y" =: show r 
                             <> "width" =: "1" 
                             <> "height" =: "1" 
                             <> "fill" =: if (r + c) `mod` 2 == 0 then "blue" else "grey")
               $ return ()
    return $ const (SetStart cell) <$> domEvent Click el 


-- | Display a single line of the path
showMove :: MonadWidget t m => (Cell, Cell) -> m ()
showMove ((r0, c0), (r1, c1)) = do
    elDynAttrNS' svgNamespace "line" 
         (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                   <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                   <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                   <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                   <> "style" =: "stroke:yellow;stroke-width:0.05" )
         $ return ()
    return ()


-- | Display both the static board and the dynamic tour.
-- | Return the event fired when a checker is clicked.
render :: MonadWidget t m => Board -> Dynamic t Tour -> m (Event t Msg)
render board tour = do
    checkerEv <- sequence $ fmap showChecker board

    let getMoves :: [Cell] -> [(Cell,Cell)]  -- The Cell to Cell moves in a tour
        getMoves tour = zip tour $ tail tour 

    moveMap <- mapDyn (fromSet (const ()) . fromList . getMoves) tour 
    listWithKey moveMap (\c _ -> showMove c)

    return $ leftmost checkerEv


outlineStyle width = "style" =: ("width: " ++ show width ++ "px; border: 5px solid navy;")
floatWithPaddingStyle = "style" =: "float:left;padding:10px" 
centerTextStyle = "style" =: "text-align: center" 

-- | Draw a tour against a checkered board
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Int -> Int -> Int -> Int -> Board -> Dynamic t Tour -> m (Event t Msg)
view width height rowCount colCount board tour = do
    unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour

    elAttr "div" (outlineStyle width) $ do
        elAttr "h2" centerTextStyle $ dynText unvisited
        elAttr "h3" centerTextStyle $ text "(pick a square)"
        el "div" $ do
            (_, ev) <- elDynAttrNS' svgNamespace "svg" 
                            (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                      <> "width" =: show width
                                      <> "height" =: show height)
                            $ render board tour
            return ev

fps  = "style" =: "float:left;padding:10px" 

knightsTour width height rowCount colCount dt = do
    let 
        board = [(r,c) | r <- [0..rowCount-1], c <- [0..colCount-1] ]
    now <- liftIO getCurrentTime 
    advanceEvent <- fmap (const Advance) <$> tickLossy dt now
    rec
        startEvent <- view width height rowCount colCount board tour
        tour <- foldDyn (update board) [] $ leftmost [startEvent, advanceEvent]
    return ()

main :: IO ()
main = mainWidget $ do
          elAttr "div" fps $ knightsTour 300 300 8 8 0.15
          elAttr "div" fps $ knightsTour 200 200 12 12 0.05
          elAttr "div" fps $ knightsTour 350 350 6 6 0.25
          return ()

