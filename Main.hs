{-# LANGUAGE RecursiveDo #-}
import           Data.Map (Map, fromSet, elems)
import           Data.Set (fromList)
import           Data.List (minimumBy)
import           Reflex.Dom
import           Reflex.Dom.Time
import           Data.Time.Clock
import           Data.Monoid ((<>))
import           Data.Function (on)

type Cell = (Int, Int)
type Tour = [Cell]
type Board = [Cell]

data Action = Advance | SetStart Cell

-- | Return a list of locations that can be reached in one move.
nextMoves :: Board -> Tour -> Cell -> [Cell]
nextMoves board tour (x,y) = 
  let c = [ 1,  2, -1, -2]
      km = [(cx, cy) | cx <- c, cy <- c, abs cx /= abs cy]
      jumps = map (\(kx, ky) -> (x + kx , y + ky)) km
  in filter (\j -> elem j board && notElem j tour ) jumps

-- | Return the preferred location reachable in one move.
bestMove :: Board -> Tour -> Maybe Cell
bestMove board tour = 
    case tour of 
    [] -> Nothing -- if no tour in progress then no best move.
    (x:_) -> 
        let options = nextMoves board tour x
        in case options of
           [] -> Nothing -- if no next move then no best move.
           _ -> Just $ minimumBy (compare `on` (length . nextMoves board tour)) options


-- | Given a board, an action and existing tour, return an updated tour.
update :: Board -> Action -> Tour -> Tour
update board action tour =
    case action of
        SetStart start -> [start] 
        Advance ->  case bestMove board tour of
                     Nothing -> tour
                     Just best -> best:tour

-- | Draw a tour against a checkered board
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Int -> Int -> Int -> Int -> Board -> Dynamic t Tour -> m (Event t Action)
view width height rowCount colCount board tour = 
    let 
        ns = Just "http://www.w3.org/2000/svg"

        fillColor (r,c) = if (r + c) `mod` 2 == 0 then "blue" else "grey"

        showChecker :: MonadWidget t m => Cell -> m (Event t Action)
        showChecker cell@(r, c) = do
            (el, ev) <- elDynAttrNS' ns "rect" 
                           (constDyn $  "x" =: show c 
                                     <> "y" =: show r 
                                     <> "width" =: "1" 
                                     <> "height" =: "1" 
                                     <> "fill" =: fillColor cell)
                       $ return ()
            return $ const (SetStart cell) <$> domEvent Click el 

        showMove :: MonadWidget t m => (Cell, Cell) -> m (Event t ())
        showMove ((r0, c0), (r1, c1)) = do
            elDynAttrNS' ns "line" 
                 (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                           <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                           <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                           <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                           <> "style" =: "stroke:yellow;stroke-width:0.05" ) 
                 $ return ()
            return never

        render :: MonadWidget t m => Board -> Dynamic t Tour -> m (Event t Action)
        render board tour = do
            checkerEv <- sequence $ fmap showChecker board
            let getMoves tour = zip tour $ tail tour
            moveMap <- mapDyn (fromSet (const ()) . fromList . getMoves) tour 
            listWithKey moveMap (\c _ -> showMove c)
            return $ leftmost checkerEv

        border = "style" =: ("width: " ++ show width ++ "px; border: 5px solid navy;")

        centerText = "style" =: "text-align: center" 

    in do
        unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour


        elAttr "div" border $ do
            elAttr "h2" centerText $ dynText unvisited
            elAttr "h3" centerText $ text "(pick a square)"
            el "div" $ do
                (_, ev) <- elDynAttrNS' ns "svg" 
                                (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                          <> "width" =: show width
                                          <> "height" =: show height)
                                $ elStopPropagationNS ns "g" Click $ render board tour
                return ev

main :: IO ()
main = 
    do
        startTime <- getCurrentTime
        mainWidget $ do

            let rowCount = 10
                colCount = 10
                width = 400
                height = 400
                dt = 0.1

            let board = [(r,c) | r <- [0..rowCount-1], c <- [0..colCount-1] ]
            ticks <- fmap (const Advance) <$> tickLossy dt startTime 
            rec
                selection <- view width height colCount rowCount board tour 
                tour <- foldDyn (update board) []  $ mergeWith const [selection, ticks]
            return ()

