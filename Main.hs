{-# LANGUAGE RecursiveDo #-}
import           Data.Map (Map, fromList, elems)
import           Data.List (minimumBy)
import           Reflex.Dom
import           Reflex.Dom.Time
import           Data.Time.Clock
import           Data.Monoid ((<>))
import           Data.Function (on)

-- parameters
w = 450
h = 450
rowCount=12
colCount=12
dt = 0.05

type Cell = (Int, Int)

type Tour = [Cell]

board = do r <- [0..rowCount-1] 
           c <- [0..colCount-1] 
           [(r,c)]

data Action = Tick | SetStart Cell

-- | Draw a tour against a checkered background.  
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Dynamic t Tour -> m (Event t Action)
view tour = do
    let 
        ns = Just "http://www.w3.org/2000/svg"

        fillColor (r,c) = if (r + c) `mod` 2 == 0 then "blue" else "grey"

        showChecker :: MonadWidget t m => Cell -> m (Event t Action)
        showChecker cell@(r, c) = do
            (el, ev) <- elDynAttrNS' ns "rect" 
                           (constDyn $  "x" =: show c 
                                     <> "y" =: show r 
                                     <> "width" =: "1" 
                                     <> "height" =: "1" 
                                     <> "fill" =: fillColor cell)
                       $ return ()
            return $ const (SetStart cell) <$> domEvent Click el 

        showMove :: MonadWidget t m => (Cell, Cell) -> m (Event t ())
        showMove ((r0, c0), (r1, c1)) = do
            elDynAttrNS' ns "line" 
                 (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                           <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                           <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                           <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                           <> "style" =: "stroke:yellow;stroke-width:0.05" ) 
                 $ return ()
            return never

        render :: MonadWidget t m => Dynamic t Tour -> m (Event t Action)
        render tour = do
            checkerEv <- sequence $ fmap showChecker board

            let getMoves tour = zip tour $ tail tour

            moveMap <- mapDyn (fromList . map (\c -> (c,())) . getMoves) tour 
            listWithKey moveMap (\c _ -> showMove c)

            return $ leftmost checkerEv

        center = "style" =: "text-align: center;"

    unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour

    el "div" $ do
        elAttr "h2" center $ text "Knight's Tour"
        elAttr "h2" center $ dynText unvisited
        elAttr "h2" center $ text "(pick a square)"
        elAttr "div" center $ do
            (_, ev) <- elDynAttrNS' ns "svg" 
                            (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                      <> "width" =: show w
                                      <> "height" =: show h)
                        $ elStopPropagationNS ns "g" Click $ render tour
            return ev

-- | Return a list of locations that can be reached in one move.
nextMoves :: Tour -> Cell -> [Cell]
nextMoves tour startCell = 
  let c = [ 1,  2, -1, -2]

      km = do cx <- c
              cy <- c
              if abs cx == abs cy then [] else [(cx,cy)]

      jumps = map (\cell -> (fst cell + fst startCell, snd cell + snd startCell)) km

  in filter (\j -> elem j board && notElem j tour ) jumps

-- | Return the preferred location reachable in one move.
bestMove :: Tour -> Maybe Cell
bestMove tour = 
    let options = (nextMoves tour $ head tour)
    in if null options 
       then Nothing 
       else Just $ minimumBy (compare `on` (length . nextMoves tour)) options

-- | Given an action and existing tour, return an updated tour.
update :: Action -> Tour -> Tour
update action tour =
    case action of
        SetStart start -> [start] 
        Tick ->  
            if null tour then tour 
            else case bestMove tour of
                     Nothing -> tour
                     Just best -> best:tour

main :: IO ()
main = do
    startTime <- getCurrentTime
    mainWidget $ do
        ticks <- fmap (const Tick) <$> tickLossy dt startTime 
        rec selection <- view tour
            tour <- foldDyn update []  $ mergeWith const [selection, ticks]
        return ()
