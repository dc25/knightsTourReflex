{-# LANGUAGE RecursiveDo #-}
import Data.Map (Map, fromSet, elems)
import Data.Set (fromList)
import Data.List (minimumBy)
import Reflex.Dom (MonadWidget, Dynamic, Event, (=:), mainWidget, el, elAttr, elDynAttr, elDynAttrNS', elStopPropagationNS, text, textInput, dynText, constDyn, mapDyn, mergeWith, foldDyn, EventName(Click), listWithKey, leftmost, domEvent, def, value)
import Reflex.Dom.Time (tickLossy)
import Data.Time.Clock (getCurrentTime)
import Data.Monoid ((<>))
import Data.Function (on)

type Cell = (Int, Int)
type Tour = [Cell]
type Board = [Cell]

data Action = Advance | SetStart Cell

-- | Return a list of locations that can be reached in one move.
nextMoves :: Board -> Tour -> Cell -> [Cell]
nextMoves board tour (x,y) = 
    [pos | let c = [ 1,  2, -1, -2],
           cx <- c, 
           cy <- c, 
           abs cx /= abs cy,
           let pos = (x+cx, y+cy),
           pos `elem` board,
           pos `notElem` tour ]

-- | Return the preferred location reachable in one move.
bestMove :: Board -> Tour -> Maybe Cell
bestMove board tour = 
    case tour of 
    [] -> Nothing -- if no tour in progress then no best move.
    (x:_) -> 
        let options = nextMoves board tour x
        in case options of
           [] -> Nothing -- if no next move then no best move.
           _ -> Just $ minimumBy (compare `on` (length . nextMoves board tour)) options


-- | Given a board, an action and existing tour, return an updated tour.
update :: Board -> Action -> Tour -> Tour
update board action tour =
    case action of
        SetStart start -> [start] 
        Advance ->  case bestMove board tour of
                     Nothing -> tour
                     Just best -> best:tour



-- | Namespace needed for svg elements.
svgNamespace = Just "http://www.w3.org/2000/svg"

-- | Display a single checker.
-- | Return click event with checker's location.
showChecker :: MonadWidget t m => Cell -> m (Event t Action)
showChecker cell@(r, c) = do
    (el, _) <- elDynAttrNS' svgNamespace "rect" 
                   (constDyn $  "x" =: show c 
                             <> "y" =: show r 
                             <> "width" =: "1" 
                             <> "height" =: "1" 
                             <> "fill" =: if (r + c) `mod` 2 == 0 then "blue" else "grey")
               $ return ()
    return $ const (SetStart cell) <$> domEvent Click el 


-- | Display a single line of the path
showMove :: MonadWidget t m => (Cell, Cell) -> m ()
showMove ((r0, c0), (r1, c1)) = do
    elDynAttrNS' svgNamespace "line" 
         (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                   <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                   <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                   <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                   <> "style" =: "stroke:yellow;stroke-width:0.05" )
         $ return ()
    return ()


-- | Display both the static board and the dynamic tour.
-- | Return the event fired when a checker is clicked.
render :: MonadWidget t m => Board -> Dynamic t Tour -> m (Event t Action)
render board tour = do
    checkerEv <- sequence $ fmap showChecker board

    let getMoves :: [Cell] -> [(Cell,Cell)]  -- The Cell to Cell moves in a tour
        getMoves tour = zip tour $ tail tour 

    -- listWithKey wants a map as first argument.
    -- Use of this map lets listWithKey track changing dynamic content
    -- and minimizes redraw.
    moveMap <- mapDyn (fromSet (const ()) . fromList . getMoves) tour 
    listWithKey moveMap (\c _ -> showMove c)

    -- Using mapDyn/dyn (below) works but is slower than mapDyn/listWithKey
    -- showMoveList <- mapDyn (mapM showMove.getMoves) tour 
    -- dyn showMoveList
    
    return $ leftmost checkerEv


outlineStyle width = "style" =: ("width: " ++ show width ++ "px; border: 5px solid navy;")
floatWithPaddingStyle = "style" =: "float:left;padding:10px" 
centerTextStyle = "style" =: "text-align: center" 

-- | Draw a tour against a checkered board
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Int -> Int -> Int -> Int -> Board -> Dynamic t Tour -> m (Event t Action)
view width height rowCount colCount board tour = do
    unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour

    elAttr "div" (outlineStyle width) $ do
        elAttr "h2" centerTextStyle $ dynText unvisited
        elAttr "h3" centerTextStyle $ text "(pick a square)"
        el "div" $ do
            (_, ev) <- elDynAttrNS' svgNamespace "svg" 
                            (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                      <> "width" =: show width
                                      <> "height" =: show height)
                            $ render board tour
            return ev




main :: IO ()
main = 
    do
        startTime <- getCurrentTime
        mainWidget $ do

            let width = 400
                height = 400
                rowCount = 8
                colCount = 8
                dt = 0.05

            let board = [(r,c) | r <- [0..rowCount-1], c <- [0..colCount-1] ]
            advanceEvent <- fmap (const Advance) <$> tickLossy dt startTime 
            rec
                setStartEvent <- view width height rowCount colCount board tour 
                tour <- foldDyn (update board) []  $ mergeWith const [setStartEvent, advanceEvent]
            return ()

