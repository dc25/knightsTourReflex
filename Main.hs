{-# LANGUAGE RecursiveDo #-}
import           Data.Map (Map, fromSet, elems)
import           Data.Set (fromList)
import           Data.List (minimumBy)
import           Reflex.Dom
import           Reflex.Dom.Time
import           Data.Time.Clock
import           Data.Monoid ((<>))
import           Data.Function (on)

type Cell = (Int, Int)
type Tour = [Cell]
type Board = [Cell]

data Action = Tick | SetStart Cell


-- | Draw a tour against a checkered board
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Int -> Int -> Int -> Int -> Board -> Dynamic t Tour -> m (Event t Action)
view width height rowCount colCount board tour = 
    let 
        ns = Just "http://www.w3.org/2000/svg"

        fillColor (r,c) = if (r + c) `mod` 2 == 0 then "blue" else "grey"

        showChecker :: MonadWidget t m => Cell -> m (Event t Action)
        showChecker cell@(r, c) = do
            (el, ev) <- elDynAttrNS' ns "rect" 
                           (constDyn $  "x" =: show c 
                                     <> "y" =: show r 
                                     <> "width" =: "1" 
                                     <> "height" =: "1" 
                                     <> "fill" =: fillColor cell)
                       $ return ()
            return $ const (SetStart cell) <$> domEvent Click el 

        showMove :: MonadWidget t m => (Cell, Cell) -> m (Event t ())
        showMove ((r0, c0), (r1, c1)) = do
            elDynAttrNS' ns "line" 
                 (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                           <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                           <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                           <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                           <> "style" =: "stroke:yellow;stroke-width:0.05" ) 
                 $ return ()
            return never

        render :: MonadWidget t m => Board -> Dynamic t Tour -> m (Event t Action)
        render board tour = do
            checkerEv <- sequence $ fmap showChecker board
            let getMoves tour = zip tour $ tail tour
            moveMap <- mapDyn (fromSet (const ()) . fromList . getMoves) tour 
            listWithKey moveMap (\c _ -> showMove c)
            return $ leftmost checkerEv
        border = "style" =: "border: 5px solid navy;"

    in do
        unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour


        elAttr "div" border $ do
            el "h2" $ dynText unvisited
            el "div" $ do
                (_, ev) <- elDynAttrNS' ns "svg" 
                                (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                          <> "width" =: show width
                                          <> "height" =: show height)
                                $ elStopPropagationNS ns "g" Click $ render board tour
                return ev

-- | Return a list of locations that can be reached in one move.
nextMoves :: Board -> Tour -> Cell -> [Cell]
nextMoves board tour (x,y) = 
  let c = [ 1,  2, -1, -2]
      km = [(cx, cy) | cx <- c, cy <- c, abs cx /= abs cy]
      jumps = map (\(kx, ky) -> (x + kx , y + ky)) km
  in filter (\j -> elem j board && notElem j tour ) jumps

-- | Return the preferred location reachable in one move.
bestMove :: Board -> Tour -> Maybe Cell
bestMove board tour = 
    case tour of 
    [] -> Nothing
    (x:xs) -> 
        let options = nextMoves board tour x
        in case options of
           [] -> Nothing 
           _ -> Just $ minimumBy (compare `on` (length . nextMoves board tour)) options


-- | Given a board, an action and existing tour, return an updated tour.
update :: Board -> Action -> Tour -> Tour
update board action tour =
    case action of
        SetStart start -> [start] 
        Tick ->  case bestMove board tour of
                     Nothing -> tour
                     Just best -> best:tour

knightsTour :: MonadWidget t m => UTCTime -> Int -> Int -> Int -> Int -> NominalDiffTime -> m ()
knightsTour startTime width height rowCount colCount dt = do 
    ticks <- fmap (const Tick) <$> tickLossy dt startTime 
    let board = [(r,c) | r <- [0..rowCount-1], c <- [0..colCount-1] ]
    rec selection <- view width height rowCount colCount board tour 
        tour <- foldDyn (update board) []  $ mergeWith const [selection, ticks]
    return ()

main :: IO ()
main = 
    let
        fl = "style" =: "float: left; padding: 10px"
        cb = "style" =: "clear: both"
    in do
        startTime <- getCurrentTime
        mainWidget $ do
            elAttr "div" fl $ 
                knightsTour startTime 240 240 7 7 0.15
            elAttr "div" fl $ 
                knightsTour startTime 230 230 10 10 0.07
            elAttr "div" cb $ 
                return ()
            elAttr "div" fl $ 
                knightsTour startTime 250 250 6 6 0.3
            elAttr "div" fl $ 
                knightsTour startTime 210 210 8 8 0.05

