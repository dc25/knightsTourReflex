{-# LANGUAGE RecursiveDo #-}
import           Data.Map (Map, fromSet, elems)
import           Data.Set (fromList)
import           Data.List (minimumBy)
import           Reflex.Dom
import           Reflex.Dom.Time
import           Data.Time.Clock
import           Data.Monoid ((<>))
import           Data.Function (on)

type Cell = (Int, Int)
type Tour = [Cell]
type Board = [Cell]

data Action = Advance | SetStart Cell

-- | Return a list of locations that can be reached in one move.
nextMoves :: Board -> Tour -> Cell -> [Cell]
nextMoves board tour (x,y) = 
  let c = [ 1,  2, -1, -2]
      km = [(cx, cy) | cx <- c, cy <- c, abs cx /= abs cy]
      jumps = map (\(kx, ky) -> (x + kx , y + ky)) km
  in filter (\j -> elem j board && notElem j tour ) jumps

-- | Return the preferred location reachable in one move.
bestMove :: Board -> Tour -> Maybe Cell
bestMove board tour = 
    case tour of 
    [] -> Nothing -- if no tour in progress then no best move.
    (x:_) -> 
        let options = nextMoves board tour x
        in case options of
           [] -> Nothing -- if no next move then no best move.
           _ -> Just $ minimumBy (compare `on` (length . nextMoves board tour)) options


-- | Given a board, an action and existing tour, return an updated tour.
update :: Board -> Action -> Tour -> Tour
update board action tour =
    case action of
        SetStart start -> [start] 
        Advance ->  case bestMove board tour of
                     Nothing -> tour
                     Just best -> best:tour



-- | Styles used here and there...
outlineStyle width = "style" =: ("width: " ++ show width ++ "px; border: 5px solid navy;")
centerTextStyle = "style" =: "text-align: center" 
yellowLineStyle = "style" =: "stroke:yellow;stroke-width:0.05" 
floatWithPaddingStyle = "style" =: "float:left;padding:10px" 

-- | Namespace needed for svg elements.
svgNamespace = Just "http://www.w3.org/2000/svg"

-- | Display a single checker.
-- | Return click event with checker's location.
showChecker :: MonadWidget t m => Cell -> m (Event t Action)
showChecker cell@(r, c) = do
    (el, ev) <- elDynAttrNS' svgNamespace "rect" 
                   (constDyn $  "x" =: show c 
                             <> "y" =: show r 
                             <> "width" =: "1" 
                             <> "height" =: "1" 
                             <> "fill" =: if (r + c) `mod` 2 == 0 then "blue" else "grey")
               $ return ()
    return $ const (SetStart cell) <$> domEvent Click el 

-- | Display a single line of the path
showMove :: MonadWidget t m => (Cell, Cell) -> m ()
showMove ((r0, c0), (r1, c1)) = do
    elDynAttrNS' svgNamespace "line" 
         (constDyn $  "x1" =: show ((fromIntegral c0 :: Float) + 0.5)
                   <> "y1" =: show ((fromIntegral r0 :: Float) + 0.5)
                   <> "x2" =: show ((fromIntegral c1 :: Float) + 0.5)
                   <> "y2" =: show ((fromIntegral r1 :: Float) + 0.5)
                   <> yellowLineStyle)
         $ return ()
    return ()

-- | Draw a tour against a checkered board
-- | Return the event generated by clicking a checker.
view :: MonadWidget t m => Int -> Int -> Int -> Int -> Board -> Dynamic t Tour -> m (Event t Action)
view width height rowCount colCount board tour = 
    let 

        -- | Display both the static board and the dynamic tour.
        -- | Return the event fired when a checker is clicked.
        render :: MonadWidget t m => Board -> Dynamic t Tour -> m (Event t Action)
        render board tour = do
            checkerEv <- sequence $ fmap showChecker board

            let getMoves :: [Cell] -> [(Cell,Cell)]  -- The Cell to Cell moves in a tour
                getMoves tour = zip tour $ tail tour 

            moveMap <- mapDyn (fromSet (const ()) . fromList . getMoves) tour 
            listWithKey moveMap (\c _ -> showMove c)

            -- Using mapDyn/dyn works but is slower than mapDyn/listWithKey
            -- showMoveList <- mapDyn (mapM showMove.getMoves) tour 
            -- dyn showMoveList
            
            return $ leftmost checkerEv

    in do
        unvisited <- mapDyn (\m -> "unvisited count = " ++ show (length board - length m)) tour

        elAttr "div" (outlineStyle width) $ do
            elAttr "h2" centerTextStyle $ dynText unvisited
            elAttr "h3" centerTextStyle $ text "(pick a square)"
            el "div" $ do
                (_, ev) <- elDynAttrNS' svgNamespace "svg" 
                                (constDyn $  "viewBox" =: ("0 0 " ++ show colCount ++ " " ++ show rowCount)
                                          <> "width" =: show width
                                          <> "height" =: show height)
                                $ elStopPropagationNS svgNamespace "g" Click $ render board tour
                return ev

main :: IO ()
main = 
    do
        startTime <- getCurrentTime
        mainWidget $ do

            let width = 400
                height = 400
                rowCount = 12
                colCount = 12
                dt = 0.05

            let board = [(r,c) | r <- [0..rowCount-1], c <- [0..colCount-1] ]
            advanceEvent <- fmap (const Advance) <$> tickLossy dt startTime 
            rec
                setStartEvent <- view width height rowCount colCount board tour 
                tour <- foldDyn (update board) []  $ mergeWith const [setStartEvent, advanceEvent]
            return ()

